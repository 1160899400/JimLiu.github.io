---
layout: post
title:  "GreenDao 源码分析"
date:   2018-11-05
tags:
- Source Code Learning
- Android
- ORM Database
---

### GreenDao简介
&emsp;&emsp;GreenDao主要是为了简化android客户端对SQLite数据库一系列操作，而对数据库的相关操作封装的一个ORM框架，底层是基于对SQLite的封装，对比其它框架，GreenDao拥有非常好的读写性能和缓存策略。  

#### GreenDao环境配置 （Android Studio）
&emsp;&emsp;给项目添加依赖，主要是GreenDao项目和GreenDao自动生成代码的插件的依赖。配置如下：  

project下的build.gradle配置：  

```groovy
/**
 * add greendao plugin dependency to generate code automatically
 */
buildscript{
	repositories{
        ...
	}
	dependencies{
		...
        classpath 'org.greenrobot:greendao-gradle-plugin:3.2.2'
	}
}
```

app下的build.gradle配置：
```groovy
//apply 自动生成代码的 plugin
apply plugin: 'org.greenrobot.greendao'
...

android{
	//添加greendao配置
    greendao {
        //数据库版本号
        schemaVersion 1
        //数据库dao所在包
        daoPackage 'com.liu.dao'
        //生成的数据库文件的目录
        targetGenDir 'src/main/java'
        //自动生成单元测试
//        generateTests true
		//生成的单元测试目录
////    targetGenDirTests
    }
}

//添加greendao库的依赖
dependencies{
    ...
    implementation 'org.greenrobot:greendao:3.2.2'
}

```

然后Sync -> Build，Build后会生成DaoMaster，DaoSession，各个EntityDao。


#### GreenDao简单使用 （Android Studio）
&emsp;&emsp;使用GreenDao创建数据库Schema、建表，并进行简单的增删改查的步骤依次如下：  

&emsp;&emsp;首先创建一个entity实体：  
```Java
@Entity
public Class student{
	@Id(autoincrement = true)
	private long id;
    
	private String name;
	
	@Transient
	private int age;
}
```
&emsp;&emsp;然后编译，GreenDao就会自动识别带有`@Entity`注释的实体类，并为其重新生成实体类，生成的实体类代码如下：
```Java
@Entity
public class Student {
	/**
	 * @Id 标明该Field为主键，autoincrement属性代表是否自增
	*/ 
    @Id(autoincrement = true)
    public Long id;

	/**
	 * @NotNull 标明对应的数据库字段为NotNull
	 */
    @NotNull
    private String age;

    /**
     * @Transient 类似于transient关键字
     * 该变量不会被序列化，也意味着不会生成对应的数据库字段
     */
    @Transient
    private String info;

    @Generated(hash = 628442569)
    public Student(Long id, @NotNull String age) {
        this.id = id;
        this.age = age;
    }

    @Generated(hash = 1556870573)
    public Student() {
    }

    public Long getId() {
        return this.id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getAge() {
        return this.age;
    }

    public void setAge(String age) {
        this.age = age;
    }
}
```

&emsp;&emsp;可以看到生成的Entity会有一个默认的无参的Constructor和将所有不会被序列化的成员作为参数的Constructor。生成的每个Constructor都有一个@Generated(hash = xxxxxx)的注解，这里还不太清楚该注解的明确用处，推测是GreenDao用来进行缓存处理的。  

&emsp;&emsp;然后就可以通过Session对象获取相应的EntityDao进行增删改查，示例如下：  

```Java

```

对于GreenDao中所有的注解及其作用，整理如下表：

| GreenDao Annotation |                            Usage                             |
| :------------------ | :----------------------------------------------------------: |
| @Entity             | 为当前实体类在数据库建表。nameInDb属性可以设置在数据库中的表名；indexes属性可以设置索引（多列）；createInDb设置是否在数据库中建表；schema设置该表对应的schema；active设置生成的entity类有无update/delete/refresh方法；generateConstuctors设置是否生成带所有参数的constructor；generateGettersSetters设置是否生成Getter/Setter方法；protobuf设置该entity对应的protobuf类并添加该protobuf的dao类。 |
| @Id                 | 设置某field为所对应的表的主键，autoincrement属性可以设置是否自增 |
| @Property           | 指明需要映射到数据库某一字段的成员变量。nameInDb属性可以设置在数据库的列名 |
| @NotNull            |            设置该field对应的数据库的字段为NotNull            |
| @Transient          |             设置该成员变量不持久化存储到数据库中             |
| @Index              | 为该field对应的列创建索引。value属性指定索引的field，该属性只有在@index在@entity的indexes属性中才能设置，后面可以紧跟ASC或DESC指定排序顺序；name属性指定生成的索引名称，若不设置，则默认为对应的数据库中的列名；unique指定是否为索引添加Unique约束 |
| @Unique             | 修饰的field对应的数据库中的字段为Unique，且SQLite会隐式地为该列创建索引 |
| @ToOne              | 一对一关系，用来修饰当前类的某个对应着另一个entity的field，对象懒加载，第一次请求后缓存。joinProperty属性（String）指明当前类对应的表的外键 |
| @ToMany             | 一对多关系，用来修饰当前类的某个List\<Entity\> 的field，Entity对象必须含有若干对应的外键，集合懒加载，须手动修改集合或调用reset()才能重新从数据库读取。joinProperties属性（JoinProperty[]）指明所有的外键；referencedJoinProperty属性（String）指明在entity类中的外键field名称。 |
| @JoinEntity         | 多对多关系，修饰某个List\<Entity\>的field，常与@ToMany一起使用，List\<Entity\>是中间表（两个实体关系的表）的List对象。 |
| @JoinProperty       | 指定外键，常在@ToMany的joinProperties中用到。name属性指定外键在@ToMany所属的当前类的field；referencedName属性指定外键在关联的另一个类的field |
| @Generated          | 用于标记被GreenDao持久化的field/constructor/method，hash属性唯一表示当前注释的field/constructor/method，并且每次build自动生成时hash值会改变，手动修改hash值编译时会报错 |
| @Convert            | 修饰field，使该field的数据能与数据库中字段类型不同，当field需要存储到数据库或从数据库读取到field时，会进行转换。converter属性指明转换类（\<? extends PropertyConverter\>，重写`convertToEntityProperty(D databaseValue)`，`convertToDatabaseValue(P entityProperty)`接口实现不同类型数据转换的操作；columnType属性可以指明数据库中的变量类型） |
| @Keep               | 等同于@Generated()，修饰的field/constructor/method再次编译时，不会报错 |



### GeenDao3.x与2.x的主要区别

&emsp;&emsp;GreenDao3.x和2.x版本相比，增加了编译前自动生成类文件的功能，避免自行书写代码然后手动编译运行输出类文件。3.x中可以在gradle中配置数据库版本号、生成文件的路径、单元测试文件的路径等信息，project build时就能根据Entity实体自动生成类文件及注释，而GreenDao 2.x必须手动书写生成文件的代码并编译执行。   

&emsp;&emsp;GreenDao3.x中，还要在gradle中添加下面的dependency，这样在Sync Project时会下载一个gradle插件，用于生成类文件，添加的依赖如下。  



&emsp;&emsp;这个插件会扫描所有的带有`@Entity`注释的实体类，并读取gradle中的配置信息（主要是生成代码的输出位置），调用DaoGenerator模块生成，后面会对DaoGenerator源码分析。



### GreenDao源码分析

&emsp;&emsp;GreenDao项目源码主要分为两个Module，DaoCore和DaoGenerator。   

&emsp;&emsp;首先介绍DaoGenerator模块，这个模块主要封装了自动生成java类文件的功能，这里自动生成类文件用到了FreeMarker模板引擎，简单的来讲，通过freemaker能根据.ftl 模板文件和自定义的变量来动态输出目标文件。 生成的**DaoMaster.java**、**DaoSession.java**以及带有`@Entity`注释的实体类对应的**xxxDao.java**，并根据情况判断是否重新生成实体类。  

&emsp;&emsp;顾名思义，DaoCore模块是GreenDao核心，包含了对Database的基本操作  ......(WAIT TO COMPLETE)。DaoCore分层如下：  



&emsp;&emsp;首先根据官方提供的GreenDao用例入手分析，官方的例子中，第一步是实例化`DaoMaster.DevOpenHelper`内部类对象，这个类的继承关系为`DaoMaster.DevOpenHelper`->`DaoMaster.OpenHelper`->`DatabaseOpenHelper`->`SQLiteOpenHelper`。`DevOpenHelper`主要重写了数据库的升级操作`onUpgrade()`，默认的升级操作为删除所有表并重新建立，在这里我们可以修改并自定义升级操作。`OpenHelper`中定义了建表和传入当前数据库版本的功能。`DatabaseOpenHelper`负责将SQLiteDatabase扩展成Database。 在生成的文件中，DaoMaster是数据库操作的入口，这里有  

&emsp;&emsp;在生成

#### GreenDao自动生成文件的原理




