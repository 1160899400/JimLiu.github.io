---
layout: post
title:  "GreenDao 源码分析"
date:   2018-11-05
tags:
- Source Code Learning
- Android
- ORM Database
---

### GreenDao简介
&emsp;&emsp;GreenDao主要是为了简化android客户端对SQLite数据库一系列操作，而对SQLite数据库封装的一个ORM框架，所以底层是基于SQLite，对比其它框架，GreenDao拥有非常好的读写性能和缓存策略。  

#### GreenDao环境配置 （Android Studio）
&emsp;&emsp;给项目添加依赖，主要是添加GreenDao项目和GreenDao自动生成代码的插件的依赖。配置如下：  

project下的build.gradle配置：  

```groovy
/**
 * add greendao plugin dependency to generate code automatically
 */
buildscript{
	repositories{
        ...
	}
	dependencies{
		...
        classpath 'org.greenrobot:greendao-gradle-plugin:3.2.2'
	}
}
```

app下的build.gradle配置：
```groovy
//apply 自动生成代码的 plugin
apply plugin: 'org.greenrobot.greendao'
...

android{
	//添加greendao配置
    greendao {
        //数据库版本号
        schemaVersion 1
        //数据库dao所在包
        daoPackage 'com.liu.dao'
        //生成的数据库文件的目录
        targetGenDir 'src/main/java'
        //自动生成单元测试
//        generateTests true
		//生成的单元测试目录
////    targetGenDirTests
    }
}

//添加greendao库的依赖
dependencies{
    ...
    implementation 'org.greenrobot:greendao:3.2.2'
}

```

然后Sync -> Build，Build后会生成DaoMaster，DaoSession，各个EntityDao。


#### GreenDao简单使用 （Android Studio）
&emsp;&emsp;使用GreenDao创建数据库Schema、建表，并进行简单的增删改查的步骤依次如下：  

&emsp;&emsp;首先创建一个entity实体：  
```Java
@Entity
public Class student{
	@Id(autoincrement = true)
	private long id;
    
	private String name;
	
	@Transient
	private int age;
}
```
&emsp;&emsp;然后编译，GreenDao就会自动识别带有`@Entity`注释的实体类，并为其重新生成实体类，生成的实体类代码如下：
```Java
@Entity
public class Student {
	/**
	 * @Id 标明该Field为主键，autoincrement属性代表是否自增
	*/ 
    @Id(autoincrement = true)
    public Long id;

	/**
	 * @NotNull 标明对应的数据库字段为NotNull
	 */
    @NotNull
    private String age;

    /**
     * @Transient 类似于transient关键字
     * 该变量不会被序列化，也意味着不会生成对应的数据库字段
     */
    @Transient
    private String info;

    @Generated(hash = 628442569)
    public Student(Long id, @NotNull String age) {
        this.id = id;
        this.age = age;
    }

    @Generated(hash = 1556870573)
    public Student() {
    }

    public Long getId() {
        return this.id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getAge() {
        return this.age;
    }

    public void setAge(String age) {
        this.age = age;
    }
}
```

&emsp;&emsp;可以看到生成的Entity会有一个默认的无参的Constructor和将所有不会被序列化的成员作为参数的Constructor。生成的每个Constructor都有一个@Generated(hash = xxxxxx)的注解，这里还不太清楚该注解的明确用处，推测是GreenDao用来进行缓存处理的。  

&emsp;&emsp;然后就可以通过Session对象获取相应的EntityDao进行增删改查，示例如下：  

```Java

```

对于GreenDao中所有的注解及其作用，整理如下表：



### GreenDao源码分析

&emsp;&emsp;GreenDao项目源码主要分为三个Module，DaoCore，DaoGenerator，greendao-api。   

&emsp;&emsp;首先介绍最简单的greendao-api，因为这个module基本都是greendao的注解，整理如下表：   

| GreenDao Annotation | Usage                                                        |
| :------------------ | :----------------------------------------------------------- |
| @Entity             | 为当前实体类在数据库建表。<br>nameInDb属性可以设置在数据库中的表名；<br>indexes属性可以设置索引（多列）；<br>createInDb设置是否在数据库中建表；<br>schema设置该表对应的schema；<br>active设置生成的entity类内部有无update/delete/refresh方法，若entity具有一对多关系，active值总为true；<br>generateConstuctors设置是否生成带所有参数的constructor；<br>generateGettersSetters设置是否生成Getter/Setter方法；<br>protobuf设置该entity对应的protobuf类并添加该protobuf的dao类。 |
| @Id                 | 设置某field为所对应的表的主键。<br>autoincrement属性可以设置是否自增 |
| @Property           | 指明需要映射到数据库某一字段的成员变量。nameInDb属性可以设置在数据库的列名 |
| @NotNull            | 设置该field对应的数据库的字段为NotNull                       |
| @Transient          | 设置该成员变量不持久化存储到数据库中                         |
| @Index              | 为该field对应的列创建索引。<br>value属性指定索引的field，该属性只有在@index在@entity的indexes属性中才能设置，后面可以紧跟"ASC" 或 "DESC" 指定排序顺序；<br>name属性指定生成的索引名称，若不设置，则默认为对应的数据库中的列名；unique指定是否为索引添加Unique约束 |
| @Unique             | 修饰的field对应的数据库中的字段为Unique，且SQLite会隐式地为该列创建索引 |
| @ToOne              | 一对一关系，用来修饰当前类的某个对应着另一个entity的field，对象懒加载，第一次请求后缓存。<br>joinProperty属性（String）指明当前类对应的表的外键 |
| @ToMany             | 一对多关系，用来修饰当前类的某个List\<Entity\> 的field，Entity对象必须含有若干对应的外键，集合懒加载，须手动修改集合或调用resetXXX()才能重新从数据库读取。<br>joinProperties属性（JoinProperty[]）指明所有的外键；referencedJoinProperty属性（String）指明在另一个entity类中的外键field名称。 |
| @JoinEntity         | 多对多关系，修饰某个List\<Entity\>的field，常与@ToMany一起使用，List\<Entity\>是中间表（两个实体关系的表）的List对象。 |
| @JoinProperty       | 指定外键，常在@ToMany的joinProperties中用到。<br>name属性指定外键在@ToMany所属的当前类的field；<br>referencedName属性指定外键在关联的另一个类的field |
| @Generated          | 用于标记被GreenDao持久化的field/constructor/method。<br>hash属性唯一表示当前注释的field/constructor/method，并且每次build自动生成时hash值会改变，手动修改hash值编译时会报错 |
| @Convert            | 修饰field，使该field的数据能与数据库中字段类型不同，当field需要存储到数据库或从数据库读取到field时，会进行转换。<br>converter属性指明转换类（\<? extends PropertyConverter\>，重写`convertToEntityProperty(D databaseValue)`，`convertToDatabaseValue(P entityProperty)`接口实现不同类型数据转换的操作；columnType属性可以指明数据库中的变量类型） |
| @Keep               | 等同于@Generated()，修饰的field/constructor/method再次编译时，不会报错 |
| @OrderBy            | 修饰List\<Entity\>的field，指定List的排序，默认为ASC排序。   |

&emsp;&emsp;这里需要稍微留意一下的是使用@convert注解时，一般需要再定义一个Converter类重写不同类型的转换规则。  

&emsp;&emsp;然后介绍一下DaoGenerator模块，顾名思义，这个模块封装了自动生成Java文件的功能，供greendao的gradle插件调用，并且依赖的greendao库中不会包含这个module。这里再介绍一下GreenDao自动生成类文件的原理，3.x版本的greendao的原理与2.x以及其它某些框架不同，它是在项目编译前通过gradle插件调用DaoGenerator模块自动生成的，而其它项目是在程序运行期生成的。GreenDao的gradle插件通过扫描project下带有@Enity注解的Entity类以及app/build.gradle中greendao配置信息，创建schema，然后调用DaoGenerator的`generateAll()`。  

&emsp;&emsp;DaoGenerator在生成的时候用到了FreeMarker模板引擎，简单的来讲，通过freemarker能根据.ftl 模板文件和自定义的变量来动态输出目标文件。 按**DaoMaster.java**、**DaoSession.java**以及带有`@Entity`注释的Entity类对应各个的**EntityDao.java**，并根据情况判断是否重新生成实体类。  


### DaoCore源码分析

&emsp;&emsp;顾名思义，DaoCore模块是GreenDao核心，包含了对Database的基本操作。 首先通过官方提供的GreenDao用例入手，官方示例如下：
```Java
	// do this once, for example in your Application class
	helper = new DaoMaster.DevOpenHelper(this, "notes-db", null);
	db = helper.getWritableDatabase();
	daoMaster = new DaoMaster(db);
	daoSession = daoMaster.newSession();
	// do this in your activities/fragments to get hold of a DAO
	noteDao = daoSession.getNoteDao();
```

&emsp;&emsp;官方的例子中，第一步是实例化`DaoMaster.DevOpenHelper`内部类对象，这个类的继承关系为`DaoMaster.DevOpenHelper`->`DaoMaster.OpenHelper`->`DatabaseOpenHelper`->`SQLiteOpenHelper`。  

&emsp;&emsp;`DevOpenHelper`主要重写了数据库的升级操作`onUpgrade()`，源码如下：
```Java
/** WARNING: Drops all table on Upgrade! Use only during development. */
public static class DevOpenHelper extends OpenHelper {
    public DevOpenHelper(Context context, String name) {
        super(context, name);
    }

    public DevOpenHelper(Context context, String name, CursorFactory factory) {
         super(context, name, factory);
    }

    @Override
    public void onUpgrade(Database db, int oldVersion, int newVersion) {
         Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables");
         dropAllTables(db, true);
         onCreate(db);
     }
}
```
&emsp;&emsp;可以看到默认的升级操作为删除所有表并重新建立，这样每当我们修改数据库版本时，会执行默认的数据库升级操作，将所有的本地数据库上的数据全部清楚再重新建表，这样显然不符合开发的需求，所以在这里我们可以自定义升级操作，修改这个函数。  

&emsp;&emsp;接下来是通过DevOpenHelper的`getWritableDatabase()`方法获取一个StandardDatabase对象，这里获取到的是可读写的SQLiteDatabase的代理对象（实现了Database接口的StandardDatabase）。然后将该对象作为参数new一个DaoMaster对象，在new DaoMaster对象的过程中。  

##### DaoMaster
&emsp;&emsp;DaoMaster对象是GreenDao数据库操作的入口，该类继承AbstractDaoMaster，内部有几个返回值为DaoSession对象的方法`newSesssion()`，`newDevSession() `。平常我们使用较多的就是通过`newSession()`来获取DaoSession对象，newSession有两种重载形式，一种是将决定是否缓存的IdentityScopeType集合常量作为参数创建DaoSession，而另一种无参形式创建的DaoSession会使它的EntityDao成员都带有缓存，通过DaoSession可以get到各种EntityDao对象来实现增删改查的操作，关于使用IdentityScope来实现缓存，后面会作介绍。  

&emsp;&emsp;再来看DaoMaster的父类AbstractDaoMaster有一个很重要的成员变量daoConfigMap，变量类型为Map\<Class\<? extends AbstractDao\<?, ?\>\>, DaoConfig\>，在这个变量维护着各种EntityDao类和DaoConfig对象的映射关系，在DaoMaster的constructor函数中，会调用`super.registerDaoClass(EntityDao.class)`方法，该方法如下：
```Java
/**
 * AbstractDaoMaster.java
 */
protected void registerDaoClass(Class<? extends AbstractDao<?, ?>> daoClass) {
    DaoConfig daoConfig = new DaoConfig(db, daoClass);
    daoConfigMap.put(daoClass, daoConfig);
}
```

&emsp;&emsp;它会根据EntityDao来new一个DaoConfig对象，然后将这一对put到daoConfigMap中，Config先会将各个EntityDao的class对象和它对应的DaoConfig对象put到daoConfigMap中。DaoConfig的new过程如下：
```Java
    public DaoConfig(Database db, Class<? extends AbstractDao<?, ?>> daoClass) {
        this.db = db;
        try {
            this.tablename = (String) daoClass.getField("TABLENAME").get(null);
            Property[] properties = reflectProperties(daoClass);
            this.properties = properties;

            allColumns = new String[properties.length];

            List<String> pkColumnList = new ArrayList<String>();
            List<String> nonPkColumnList = new ArrayList<String>();
            Property lastPkProperty = null;
            for (int i = 0; i < properties.length; i++) {
                Property property = properties[i];
                String name = property.columnName;
                allColumns[i] = name;
                if (property.primaryKey) {
                    pkColumnList.add(name);
                    lastPkProperty = property;
                } else {
                    nonPkColumnList.add(name);
                }
            }
            String[] nonPkColumnsArray = new String[nonPkColumnList.size()];
            nonPkColumns = nonPkColumnList.toArray(nonPkColumnsArray);
            String[] pkColumnsArray = new String[pkColumnList.size()];
            pkColumns = pkColumnList.toArray(pkColumnsArray);

            pkProperty = pkColumns.length == 1 ? lastPkProperty : null;
            statements = new TableStatements(db, tablename, allColumns, pkColumns);

            if (pkProperty != null) {
                Class<?> type = pkProperty.type;
                keyIsNumeric = type.equals(long.class) || type.equals(Long.class) || type.equals(int.class)
                        || type.equals(Integer.class) || type.equals(short.class) || type.equals(Short.class)
                        || type.equals(byte.class) || type.equals(Byte.class);
            } else {
                keyIsNumeric = false;
            }

        } catch (Exception e) {
            throw new DaoException("Could not init DAOConfig", e);
        }
    }
```

&emsp;&emsp;DaoConfig在new的过程中，将表的表名、主键及对应的列名、所有Property以及对应的列名、TableStatements对象（用于生成sql语句）等等全部保存到本地成员变量中，供AbstractDao使用。不过要注意，这里虽然有个**IdentityScope\<?, ?\>**成员变量，但这个变量一直为null，除非调用它的`initIdentityScope(IdentityScopeType type)`函数，该函数源码如下：
```Java
public void initIdentityScope(IdentityScopeType type) {
        if (type == IdentityScopeType.None) {
            identityScope = null;
        } else if (type == IdentityScopeType.Session) {
            if (keyIsNumeric) {
                identityScope = new IdentityScopeLong();
            } else {
                identityScope = new IdentityScopeObject();
            }
        } else {
            throw new IllegalArgumentException("Unsupported type: " + type);
        }
}
```
&emsp;&emsp;其中keyIsNumeric在DaoConfig的Constructor中就已初始化，是判断主键类型是否为数字类型（long / int / short / byte以及它们的封装类都算，若是多个字段构成联合主键，也不算做数字类型）这里根据不同的主键类型生成不同的缓存对象（IdentityScopeLong / IdentityScopeObject）。  

&emsp;&emsp;数字类型主键对应的缓存对象类IdentityScopeLong见源码，这里自定义了一个LongHashMap数据结构来实现缓存的存储，LongHashMap的源码很简单，结构上比java的HashMap简单的多，Key类型为固定的long，容量初始为16（不过会随着put操作动态增加容量）。IdentityScopeLong还有ReentrantLock锁对象来实现同步的get / put（当然也有不上锁的get/put，不过这一般是给GreenDao内部跟cursor有关的来调用）。

&emsp;&emsp;再来看另一种缓存对象IdentityScopeObject，这里用到的就是java的HashMap，put / get 等函数以及成员变量都与IdentityScopeLong很类似，不过`reverseRoom()`方法（用于调整缓存的空间大小）稍有不同，因为这里使用的是HashMap，所以不能手动调整大小。有关缓存的缓存策略和相关使用会在后面继续介绍。

&emsp;&emsp;**而DaoConfig在初始化后直接放到daoConfigMap中，也就是说DaoMaster中的daoConfigMap中的DaoConfig没有设置缓存，只包含了每个Dao的其它信息**。而利用DaoConfig对象我们可以自己定义一个EntityDao对象而不需要通过DaoSession来获取，代码如下面的第3种方式：  

```Java
DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, null);
Database database = helper.getWritableDb();
DaoMaster daoMaster = new DaoMaster(database);
/**
 * 1.通过DaoSession获取StudentDao对象
 */
DaoSession daoSession = daoMaster.newSession();
StudentDao studentDao = daoSession.getStudentDao();
/**
 * 2.利用DaoSession维护的entityToDao映射来获取StudentDao
 */
StudentDao studentDao1 = (StudentDao) daoSession.getDao(Student.class);
/**
 * 3.new一个DaoConfig对象，原始对象不会设置缓存，不过可以手动设置缓存
 */
DaoConfig daoConfig = new DaoConfig(database,StudentDao.class);
// 手动设置缓存策略为Session
// daoConfig.initIdentityScope(IdentityScopeType.Session);
StudentDao studentDao2 = new StudentDao(daoConfig);
```

##### DaoSession
&emsp;&emsp;由于EntityDao是我们常用的直接操作数据库的类，上面也讲到了几个获取EntityDao的方法，这里我们通常都是利用DaoSession来get的（前两种方式）。再来看源码，前面提到过DaoMaster在new DaoSession的时候会传入参数决定是否使EntityDao带有缓存，且默认带缓存，DaoSession构造函数如下：
```Java
 public DaoSession(Database db, IdentityScopeType type, Map<Class<? extends AbstractDao<?, ?>>, DaoConfig>
            daoConfigMap) {
        super(db);
		//entityDaoConfig = daoConfigMap.get(EntityDao.class).clone;
		//entityDaoConfig.initIdentityScope(type);
		//entityDao = new EntityDao(entityDaoConfig, this);
		//registerDao(Entity.class, entityDao);

        studentDaoConfig = daoConfigMap.get(StudentDao.class).clone();
        studentDaoConfig.initIdentityScope(type);

        teacherDaoConfig = daoConfigMap.get(TeacherDao.class).clone();
        teacherDaoConfig.initIdentityScope(type);

        studentDao = new StudentDao(studentDaoConfig, this);
        teacherDao = new TeacherDao(teacherDaoConfig, this);

        registerDao(Student.class, studentDao);
        registerDao(Teacher.class, teacherDao);
        
        
    }
```
&emsp;&emsp;可以看到DaoSession在构造时从AbstractDaoMaster. daoConfigMap中获取daoConfig并copy了一份，并修改这份copy的是否缓存的属性，DaoSession在内部创建了各个EntityDao作为自己的成员并调用了`super.registerDao()`，而registerDao函数以及AbstractDaoSession类如下：  

```Java
public class AbstractDaoSession{
    private final Database db;
    private final Map<Class<?>, AbstractDao<?, ?>> entityToDao;

    private volatile RxTransaction rxTxPlain;
    private volatile RxTransaction rxTxIo;

    public AbstractDaoSession(Database db) {
        this.db = db;
        this.entityToDao = new HashMap<Class<?>, AbstractDao<?, ?>>();
    }

    protected <T> void registerDao(Class<T> entityClass, AbstractDao<T, ?> dao) {
        entityToDao.put(entityClass, dao);
    }
    
    //......省略了各种数据库操作的方法（从entityToDao获取entity对应的AbstractDao对象，再调用它的方法）
}

```
&emsp;&emsp;可以看到这里`registerDao()`函数就是把entity.class和dao对象放入到一个映射关系表中去维护，在需要利用daoSession去做增删改查的操作时可以找到对应的dao并调用，所以我们通过上面前2中方式拿到的EntityDao一般是带有缓存的。使用daoSession去做查询如下例：
```Java
	//查询主键（字段为id）值为3的Student
	DaoSession daoSession = daoMaster.newSession();
    Long studentId = 3L;
    daoSession.load(Student.class, studentId);
```

##### AbstractDao
&emsp;&emsp;再看AbstractDao\<T, K\>，这个类是所有EntityDao类的父类，代码比较长，有一千多行。这个类的官方注释如下：
```Java
/**
 * Base class for all DAOs: Implements entity operations like insert, load, delete, and query.
 * <p>
 * This class is thread-safe.
 *
 * @param <T> Entity type
 * @param <K> Primary key (PK) type; use Void if entity does not have exactly one PK
 * @author Markus
 */
/*
 * When operating on TX, statements, or identity scope the following locking order must be met to avoid deadlocks:
 * 
 * 1.) If not inside a TX already, begin a TX to acquire a DB connection (connection is to be handled like a lock)
 * 
 * 2.) The DatabaseStatement
 * 
 * 3.) identityScope
 */
```
&emsp;&emsp;可以看到泛型 T 是Entity 类，而泛型 K 是该Entity 类对应的主键的数据类型。AbstractDao的new过程如下：
```Java
 public AbstractDao(DaoConfig config, AbstractDaoSession daoSession) {
        this.config = config;
        this.session = daoSession;
        db = config.db;
        isStandardSQLite = db.getRawDatabase() instanceof SQLiteDatabase;
        identityScope = (IdentityScope<K, T>) config.getIdentityScope();
        if (identityScope instanceof IdentityScopeLong) {
            identityScopeLong = (IdentityScopeLong<T>) identityScope;
        } else {
            identityScopeLong = null;
        }
        statements = config.statements;
        pkOrdinal = config.pkProperty != null ? config.pkProperty.ordinal : -1;
    }
```
&emsp;&emsp;可以看到AbstractDao在new的时候，是直接取的DaoConfig中的IdentityScope来自己维护的。  

&emsp;&emsp;AbstractDao提供的方法比较多，涵盖了几乎所有对单张表的增删改查操作（包括结合Transaction，Cursor）等等，各个函数的功能可以查看官方注释，解释的非常清楚，我们通常也是利用Dao类的函数实现对数据库的查询和其它操作。  

&emsp;&emsp;以insert操作为例（源码如下），所有对数据库的操作（增删改查）都默认实现了同步，而且绝大多情况下都是在Transaction中做处理的（上面的注释中也提到，是为了防止死锁），而且在操作后都会put到IdentityScope缓存进行更新。  

```Java
    public long insert(T entity) {
        return executeInsert(entity, statements.getInsertStatement(), true);
    }

    private long executeInsert(T entity, DatabaseStatement stmt, boolean setKeyAndAttach) {
        long rowId;
        if (db.isDbLockedByCurrentThread()) {
            rowId = insertInsideTx(entity, stmt);
        } else {
            // Do TX to acquire a connection before locking the stmt to avoid deadlocks
            db.beginTransaction();
            try {
                rowId = insertInsideTx(entity, stmt);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
        }
        if (setKeyAndAttach) {
            updateKeyAfterInsertAndAttach(entity, rowId, true);
        }
        return rowId;
    }

    private long insertInsideTx(T entity, DatabaseStatement stmt) {
        synchronized (stmt) {
            if (isStandardSQLite) {
                SQLiteStatement rawStmt = (SQLiteStatement) stmt.getRawStatement();
                bindValues(rawStmt, entity);
                return rawStmt.executeInsert();
            } else {
                bindValues(stmt, entity);
                return stmt.executeInsert();
            }
        }
    }
```

&emsp;&emsp;**当然，GreenDao也提供了对数据库的异步操作，尽管这样做不安全**，可以参照AsyncSession，AsyncOperation，AsyncOperationExecutor等类，内部使用了线程池，每个SQL操作都会放到事务中执行，且每次事务都有50ms的延迟，这样就能将后续50ms的SQL操作merge到该事务中，减小事务的开销，当然也限制了merge的最大数量为50，官方的注释是这样的：
```Java
if (operation.isMergeTx()) {
	// Wait some ms for another operation to merge because a TX is expensive
	AsyncOperation operation2 = queue.poll(waitForMergeMillis, TimeUnit.MILLISECONDS);
	if (operation2 != null) {
		if (operation.isMergeableWith(operation2)) {
			mergeTxAndExecute(operation, operation2);
		} else {
        		// Cannot merge, execute both
				executeOperationAndPostCompleted(operation);
				executeOperationAndPostCompleted(operation2);
        }
        continue;
	}
}
```

&emsp;&emsp;查询对应的load操作也是这样，**当从IdentityScope中没有找到时才会从数据库中读取，并且读取到后立刻放入IdentityScope供下次可能的查询，这也就是GreenDao利用IdentityScope实现的缓存策略**。

&emsp;&emsp;这种缓存实现可能会让新手在接触GreenDao时有些疑惑，举个例子，[可以参考这篇文章](https://www.jianshu.com/p/1fb0c033759c)，有时我们通过Dao取出一个对象并对其中某个属性修改时（没有更新到数据库），再次通过Dao查询却发现这个属性已经更新了。原因就在于查询这个操作是优先选择从缓存中读取的，第一次查询在查询完成后会将查询的结果放入缓存，所以再次查询到的也就不是数据库中的内容了。

&emsp;&emsp;当然，AbstractDao除了这些方法外还有几个特殊的方法需要做重点介绍，一个是`detach(T entity)`方法，源码如下：
```Java
/** Detaches an entity from the identity scope (session). Subsequent query results won't return this object. */
    public boolean detach(T entity) {
        if (identityScope != null) {
            K key = getKeyVerified(entity);
            return identityScope.detach(key, entity);
        } else {
            return false;
        }
    }
```
&emsp;&emsp;这里可以看到是调用AbstractDao维护的identityScope的detach()方法来清除当前Dao类的缓存。所以这个方法就能很好地解决上面遇到的问题，在每次查询后调用detach()清空缓存，下次查询就能从数据库中查询了。  

&emsp;&emsp;还有一个方法就是`queryBuilder()`来获取当前dao对应的QueryBuilder对象，QueryBuilder对象后面会作介绍。

```Java
public QueryBuilder<T> queryBuilder() {
    return QueryBuilder.internalCreate(this);
}
```
&emsp;&emsp;这里还有两个方法就是`rxPlain()`和`rx()`方法，是与RxJava结合使用相关，这里也不细说，后面介绍  


##### SqlUtils
&emsp;&emsp;这个类里面的函数都是用于创建Sql语句的String的，看这个类可以熟悉一下Sql语法。



##### QueryBuilder
&emsp;&emsp;前面讲到了EntityDao，几乎所有的简单的增删改查操作都可以通过Dao类提供的方法实现，而我们平常使用也使用的非常多。但是对于查询和删除操作，GreenDao提供了更灵活、更全面的非常好用的QueryBuilder类提供给我们（具体可见源码的Query包）。  

&emsp;&emsp;QueryBuilder类的主要成员变量与Constructor 如下：
```Java
	private final WhereCollector<T> whereCollector;
	private StringBuilder orderBuilder;
    private final List<Object> values;
    private final List<Join<T, ?>> joins;
    private final AbstractDao<T, ?> dao;
    private final String tablePrefix;

    private Integer limit;
    private Integer offset;
    private boolean distinct;

    /** stored with a leading space */
    private String stringOrderCollation;

    /** For internal use by greenDAO only. */
    public static <T2> QueryBuilder<T2> internalCreate(AbstractDao<T2, ?> dao) {
        return new QueryBuilder<T2>(dao);
    }

    protected QueryBuilder(AbstractDao<T, ?> dao) {
        this(dao, "T");
    }

    protected QueryBuilder(AbstractDao<T, ?> dao, String tablePrefix) {
        this.dao = dao;
        this.tablePrefix = tablePrefix;
        values = new ArrayList<Object>();
        joins = new ArrayList<Join<T, ?>>();
        whereCollector = new WhereCollector<T>(dao, tablePrefix);
        stringOrderCollation = " COLLATE NOCASE";
    }

    private void checkOrderBuilder() {
        if (orderBuilder == null) {
            orderBuilder = new StringBuilder();
        } else if (orderBuilder.length() > 0) {
            orderBuilder.append(",");
        }
    }
```
&emsp;&emsp;前面也讲到可以通过`Dao.queryBuilder()`获取QueryBuilder对象，当然要在外部创建一个QueryBuilder也可以通过调用`internalCreate(AbstractDao<T2, ?> dao)`实现。  

&emsp;&emsp;它的成员中有whereCollector接收where条件，通过调用`where(WhereCondition cond, WhereCondition... condMore)`函数添加whereCondition对象到WhereCollector对象中，具体见whereCondition和WhereCollector这两个类源码，这里不作细述。  

&emsp;&emsp;除此之外，orderBuilder成员用于查询时的结果排序。

&emsp;&emsp;在这个Builder模式下，最终的build函数有4种，也分别对应这4种不同的Query:
1. Query，用于查询
2. CursorQuery，用于游标查询
3. CountQuery，用于查询结果集的数量
4. DeleteQuery，用于删除

&emsp;&emsp;对于这4种Query，值得注意的是**DeleteQuery在删除数据库内的数据成功后，并不会删除IdentityScope缓存内的对应数据**，所以，最好在使用DeleteQuery删除数据后，手动调用detach清理一下缓存，否则下次查询可能出错。官方的注释如下：
```Java
/**
     * Deletes all matching entities without detaching them from the identity scope (aka session/cache). Note that this
     * method may lead to stale entity objects in the session cache. Stale entities may be returned when loaded by
     * their
     * primary key, but not using queries.
     */
    public void executeDeleteWithoutDetachingEntities() {
        checkThread();
        Database db = dao.getDatabase();
        if (db.isDbLockedByCurrentThread()) {
            dao.getDatabase().execSQL(sql, parameters);
        } else {
            // Do TX to acquire a connection before locking this to avoid deadlocks
            // Locking order as described in AbstractDao
            db.beginTransaction();
            try {
                dao.getDatabase().execSQL(sql, parameters);
                db.setTransactionSuccessful();
            } finally {
                db.endTransaction();
            }
        }
    }
```
&emsp;&emsp;这4种Query都继承自AbstractQuery，每个AbstractQuery都会包含一个ownerThread成员，用来保存当前运行的线程的线程id（后面Query做同步会用到），每种Query内部都有一个QueryData内部类继承自AbstractQueryData，这个也是用来记录每次Create Query过后的查询语句（create 最后会调用`QueryData.forCurrentThread()`函数），同样是为了多线程query时同步做准备。再来看forCurrentThread()函数,这个方法在每个Query类中都有，结果也都返回了`QueryData.forCurrentThread()`。  

&emsp;&emsp;最后再来看`QueryData.forCurrentThread()`，Query查询的多线程同步都是通过这个来实现的，源码如下：

##### GreenDao 结合RxJava


greenDao多线程同步可以通过forCurrentThread()来实现的，具体原理很简单我们看下源码就知道了

```
      //获取当前线程id
       long threadId = Thread.currentThread().getId();
      //加锁
        synchronized (queriesForThreads) {
            //queryRef是一个Map集合
            WeakReference<Q> queryRef = queriesForThreads.get(threadId);
            Q query = queryRef != null ? queryRef.get() : null;
            if (query == null) {
                gc();
                query = createQuery();
                //保存query
                queriesForThreads.put(threadId, new WeakReference<Q>(query));
            } else {
                System.arraycopy(initialValues, 0, query.parameters, 0, initialValues.length);
            }
            return query;
        }
```

这是源码的核心部分，从上面我们可以看出greenDao是通过将线程id与query对象存储在Map集合中建立1:N的映射关系，不同线程只会取出属于自己的query而不会调用其他线程的query。