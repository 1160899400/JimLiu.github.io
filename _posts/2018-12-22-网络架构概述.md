---
layout: post
title:  "网络架构概述"
date:   2018-12-11
tags:
- Basic
- Net
---

##  网络架构分层

&emsp;&emsp;对于网络架构，可以分为5个层次：**物理层(physical layer)**，**链路层（Link Layer）**，**网络层（Network Layer）**，**传输层（Transport Layer）**，**应用层(Application Layer)**。   

&emsp;&emsp;下面将按照从下层到上层的顺序，详细介绍各层的意义和各层使用到的协议（protocol）  

### 物理层
&emsp;&emsp;物理层最容易理解，所有的物理设备构成了现在的通讯网络，包括手机，电脑等终端设备的网关接口，路由器，交换机，网线，光纤等等。网络数据的发送，传输，接收都依赖这些硬件设备。

### 链路层
&emsp;&emsp;由于网络上的数据都是以电信号的方式（电信号的格式只有0/1）传输的，所以必须确定这些信号的分组方式（即大量电信号如何读写）。这时候就产生了以太网协议来规范链路层的数据传输。  

#### Frame
&emsp;&emsp;以太网的协议规定如下：一组电信号构成一个数据包，称为**Frame（帧）**（所谓帧，就是特指链路层的数据包），每一帧分为两个部分：**Header（头信息），Data（数据）**:  

- Header：一些说明项：发送者，接受者（网关的MAC地址），数据格式（编码）。
- Data：要发送的具体数据。

&emsp;&emsp;其中Header的长度固定为18字节，Data长度最短46字节，最长1500字节，所以整个帧的大小范围在64~1518个字节的范围之间。  

&emsp;&emsp;通过上面的了解，就可以大概猜测出，当数据从链路层的上层（网络层）进入链路层时，都会把数据拆分成**Frame（帧）**，然后在链路层传输。而事实也正是如此。  

#### MAC地址
&emsp;&emsp;以太网又规定，物理设备要成为网络连接的终端，必须具备**网卡**接口，像手机，电脑等设备都有网卡几口。每个网卡都有一个MAC地址**（MAC地址在网卡设备出厂时设定，在世界范围内是唯一的）**作为标识，在链路层数据传输时标记发送方和接受方的地址。  

&emsp;&emsp;关于MAC地址的格式，打开我自己的手机就可以看到，如下：

![](https://urt1rsliu.github.io/images/post/Basic/MAC&IP.jpg)


&emsp;&emsp;可以看到地址用一个12位16进制的数表示的，换算成2进制的话就是48位（6个字节）  

#### 广播
&emsp;&emsp;确定了地址的定义和数据的格式后，接下来就是数据发送的方式，这里以太网规定数据包必须确定接受者的MAC地址才能够发送出去。关于发送方如何确定接受方的MAC地址，这里就用到了**ARP协议（Address Resolution Protocol）**，它是用来将从上层传来的IP地址解析为MAC地址的。  

&emsp;&emsp;确定了接收者的MAC地址后，要将数据准确地发送给接收方，这该怎么弄，以太网用广播这种原始的方式解决了这个问题，它将Frame发送给当前子网下所有的设备，当接收方通过网卡接收时，都会将Frame的Header中的接受方MAC地址与自身MAC地址作匹配，来判断自身是不是该Frame的接收方。  

&emsp;&emsp;有了帧（Frame），网卡接口（MAC地址），广播发送，链路层就已经完全确立了。

### 网络层
&emsp;&emsp;上面介绍了链路层的传输是通过广播的方式，但是如果世界上所有设备之间数据传输都依赖广播，那么每发送一个Frame，都要准备好无数个Frame广播到其它设备，那样画面太美，无法想象......  

&emsp;&emsp;因此，网络层将所有的设备划分成一块一块的子网，同个子局域网才依赖广播的方式发送。不同的子网通过另一套协议（IP协议）来确定地址，跨子网发送时，先解析出子网地址，然后发送到该子网进行广播。

#### IP协议
&emsp;&emsp;规定网络地址的协议，IP协议分为IPv4和IPv6两个版本，它们的区别是分配的IP地址格式不同，IPv4分配的地址为32位2进制，但是通常的写法是4位256进制的形式：从0.0.0.0到255.255.255.255。IPv6的大小为128位2进制数，具体格式就不详述，只需要知道IPv6是为了解决IPv4的地址不够用的问题而提出的协议。  

##### IPv4
&emsp;&emsp;IPv4的地址通常分为两个部分，前一部分代表网络，后一部分代表主机，但是网络部分占多长是不确定的，这个还得根据子网掩码来判断。不过可以确定的是，同一子网下的IP地址，它们的网络部分是相同的。  

##### 子网掩码
&emsp;&emsp;子网掩码的长度与IP地址相同，用来决定当前IP地址哪些部分代表网络，哪些部分代表主机。子网掩码的二进制格式是由一连串1和一连串0构成的，例如子网掩码255.255.255.0（前24位是1，后8位为0），将子网掩码与IP地址做位的And运算（&），结果为1的位数是代表网络部分，结果为0的位数代表主机部分。  

&emsp;&emsp;例如，主机A的IP地址为10.0.34.70，子网掩码为255.255.0.0；主机B的IP地址为10.0.55.27，子网掩码为255.255.0.0**（主机A和B位于同一网关下）**。则它们位于同一子网下。  

##### 关于子网和网关（Gateway）
&emsp;&emsp;看到这里，有人可能对子网和网关的概念有点混淆或不理解，这里解释下，通常像路由器这样的设备本身就是一个网关，**在一个网关下，不是一定只有一个子网**，一个网关下的设备构成了一个内网，而一个内网可能包含多个子网。当数据需要跨子网传输时，都会先发送给网关，交给网关路由到指定的子网下广播。

&emsp;&emsp;所以，与内网相对的，存在着外网的概念，每个网关设备都占有自己在当前内网的IP地址，如图：

![windows下ipconfig](https://urt1rsliu.github.io/images/post/Basic/ipconfig.jpg)

&emsp;&emsp;当前所处内网的默认网关设备在该内网的ip为10.0.34.1，但是世界上的网关设备不是只有一个，那么这么多的网关设备如何连接？答案是网关设备在拥有内网IP的同时，还拥有一个外网IP，外网IP用于与其它外网设备连接。  

&emsp;&emsp;所以此时，如果一个内网设备想要单独访问一个外网设备，可以将它的数据请求转发到网关，让网关来路由到指定的外网设备。但是当一个设备处于外网，它是无法连接到另一个外网网关的内网设备的。虽然有点绕，总结地来说就是内网ip可以访问到外网ip，但外网ip无法访问到内网ip的。  

&emsp;&emsp;所以根据上面的结论，也可以推测出，分别处于2个不同网关内的2个设备是无法互相访问的，除非利用NAT（地址穿透），这里不细述。但是这两个设备是能够访问到对方所处的网关的（当然前提是知道网关的外网IP）。

#### IP数据报
&emsp;&emsp;前面讲到链路层的数据是帧的形式，在网络层，数据的形式是IP数据报，由于网络层是在链路层的上层，它的数据格式无非也就是在帧的基础上加入了网络层的特色东西——IP地址信息。  

&emsp;&emsp;IP数据报的格式与Frame类似，也是一个data加Head，它的head包含IP协议版本，长度，IP地址等信息。当IP数据报从网络层进入链路层，会将整个IP数据报放入帧的data里，然后给data添加帧的Header。所以这个时候Frame中就同时含有IP数据报的Head和Frame本身的Head。  


##### IP数据报的传输和下层处理
&emsp;&emsp;不过这里还有几个问题，由于IP数据报的最大长度是远大于Frame的Data最大长度，所以传输时，一个IP数据报就可能拆分成多个Frame来传输。还有一个问题，IP数据报是不包含MAC地址信息的，只有IP信息，那么传输到会IP数据包在传到链路层时，是如何添加MAC地址信息的呢？  

&emsp;&emsp;这里其实会对IP地址信息作一个解析，将其转换为MAC地址，然后再往Frame的head里填入MAC地址信息。关于如何将IP地址转换为MAC地址，这里分两种情况，如图：  

![](https://urt1rsliu.github.io/images/post/Basic/不同网关在网络层以及链路层的传输.PNG)

&emsp;&emsp;一是跨子网传输，前面也讲过，跨子网传输时，会直接将IP数据包丢给网关，该路由的路由，该分发到当前内网的子网的就分发，反正都是让网关去做解析。那么网关是如何解析的呢？  

&emsp;&emsp;网关会通过路由协议，找到目标设备所处的子网以及网关的MAC地址（具体怎么找的要看路由协议，我也不太懂），然后将IP数据包的接受方的MAC地址填为目标网关的MAC地址，接受方的IP地址填为接收方的IP。

&emsp;&emsp;还有一种情况就是同一子网下，前面也介绍了，会在发送广播时利用ARP协议完成IP到MAC的转换。那么ARP协议是怎么做的？  

&emsp;&emsp;ARP协议规定，当IP数据报在子网传输时，会将目标MAC地址填为 FF:FF:FF:FF:FF:FF，这样就会标识这是一个广播，于是该子网下的所有设备都会收到，设备收到后，会将自己的ip地址，与IP数据包中填写的接受方的IP地址作比较，如果相同，就会回复，向对方报告自己的MAC地址。

&emsp;&emsp;总结来说就如下表:

| 场景           | 数据包地址                  |
| -------------- | --------------------------- |
| 同一个子网络   | 对方的MAC地址，对方的IP地址 |
| 非同一个子网络 | 网关的MAC地址，对方的IP地址 |

### 传输层
&emsp;&emsp;有了上述的网络层和链路层，已经可以实现不同主机之间的通信了，但是在一个主机上有很多的应用程序，这里不用说，大家都知道会使用**端口号（port）**作区分，传输层做的工作也就是让应用程序与应用程序之间建立通信。这里对端口稍微作一个介绍：

##### Port
&emsp;&emsp;端口号是一个16位二进制数（0~65535），其中1到1023的端口被系统占用，用户自定义的端口只能选择大于1023的端口。通常有一些常见的端口，比如Http服务器端口为80，SMTP服务器端口号为25，ftp端口为20/21。  

&emsp;&emsp;那么传输层是根据什么来让不同主机上的相同应用程序通信呢，前面讲到了port来区分应用程序，这样，就可以通过主机IP+端口号来做区分了，根据主机IP加端口号，就能使特定的不同主机上的程序相互通信。对于主机+端口号，Unix系统将它封装为套接字（Socket）。而传输层的协议有以下2种：TCP和UDP，每个端口的数据传输，都会使用一个传输层协议，比如，http端口，SMTP端口，POP端口都使用TCP协议。

##### UDP协议
&emsp;&emsp;数据从传输层到网络层，需要在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。  

&emsp;&emsp;UDP数据包，也是由”标头”和”数据”两部分组成。  

&emsp;&emsp;标头部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分，而前面说过，IP数据包又是放在以太网数据包Frame中的。

##### TCP协议
&emsp;&emsp;UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。  

&emsp;&emsp;为了解决这个问题，提高网络可靠性，就出现了TCP协议。这个协议非常复杂，但可以近似认为他就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出访就知道有必要重发这个数据包了。   

&emsp;&emsp;因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。  

&emsp;&emsp;TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。  

&emsp;&emsp;有关TCP，UDP协议的深入分析，可以转到[这篇文章]()。

### 应用层
&emsp;&emsp;虽然传输层实现了应用程序之间的信息交流，但是不同的应用程序，它们的数据格式是完全不尽相同的，所以这个时候应用层的报文内部需要指明content信息。当应用层的数据进入到传输层时，直接放到TCP/UDP的data里就行了。